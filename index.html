<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script language="javascript" type="text/javascript">
	
	class Point {
		constructor(x, y, colour) {
			this.x = x;
			this.y = y;
			this.colour = colour;
		}
	}
	
	class Edge {
		constructor(p1, p2) {
			this.p1 = p1;
			this.p2 = p2;
		}
	}
		
	class Triangle {
		constructor(p1, p2, p3) {
			this.p1 = p1;
			this.p2 = p2;
			this.p3 = p3;
		}
	}	
	
	var points = [];
	var extendedPoints = [];
	var relevantPoints = [];
	var triangles = [];
	var redPoints = [];
	var bluePoints = [];
	var isColourRed = true;
	var pointColour = "red";
	var rect = 0;
	var edges = [];
	var extendedEdges = [];
	var relevantEdges = [];
	var currentPoints = [];
	var firstRandomEdge = [];
	var currentCenter = 0;
	var currentRay = 0;
	var currentlyFoundPoint = 0;
	var i = 1;
	var counterI = 0;
	var ki = 0;
	var k = 0;
	var initialPoint = 0;
	var hullPoints = [];
	var hulls = [];
	
	function calculateK(){
		k = Math.pow(2, Math.pow(2,counterI));
	}
	
	function calculate_m(){
		let m = Math.pow(k,2);
		return m;
	}
	
	function redrawAllPoints(){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		for (var i=0; i<points.length; i++){
			var point = points[i];
			ctx.beginPath();
			ctx.arc(point.x - rect.left, point.y - rect.top, 4, 0, 2*Math.PI);
			ctx.fillStyle = point.colour;
			ctx.fill();
		}
	}
	
	function redrawAllPointsCanvas2Beginning(){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext('2d');
		//rect = canvas.getBoundingClientRect();
		for (var i=0; i<points.length; i++){
			var point = points[i];
			ctx.beginPath();
			ctx.arc(point.x, point.y, 4, 0, 2*Math.PI);
			ctx.fillStyle = point.colour;
			ctx.fill();
		}
	}
	
	
	function redrawAllPointsCanvas2Next(){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext('2d');
		//rect = canvas.getBoundingClientRect();
		for (var i=0; i<points.length; i++){
			var point = points[i];
			ctx.beginPath();
			ctx.arc(point.x, point.y, 4, 0, 2*Math.PI);
			ctx.fillStyle = point.colour;
			ctx.fill();
		}
		ctx.beginPath();
		ctx.arc(currentCenter.x, currentCenter.y, 4, 0, 2*Math.PI);
		ctx.fillStyle = currentCenter.colour;
		ctx.fill();
		ctx.beginPath();
		ctx.arc(extendedPoints[extendedPoints.length-1].x, extendedPoints[extendedPoints.length-1].y, 4, 0, 2*Math.PI);
		ctx.fillStyle = extendedPoints[extendedPoints.length-1].colour;
		ctx.fill();
		ctx.beginPath();
		ctx.arc(extendedPoints[extendedPoints.length-2].x, extendedPoints[extendedPoints.length-2].y, 4, 0, 2*Math.PI);
		ctx.fillStyle = extendedPoints[extendedPoints.length-2].colour;
		ctx.fill();
		ctx.beginPath();
		ctx.arc(extendedPoints[extendedPoints.length-3].x, extendedPoints[extendedPoints.length-3].y, 4, 0, 2*Math.PI);
		ctx.fillStyle = extendedPoints[extendedPoints.length-3].colour;
		ctx.fill();
	}
	
	function redrawAllCurrentEdges(){
		for (var i=0; i<edges.length; i++){
			var edge = edges[i];
			drawSimpleLine(edge[0], edge[1]);
		}
		for (var i=0; i<relevantEdges.length; i++){
			var edge = relevantEdges[i];
			drawSimpleLine(edge.p1, edge.p2);
		}
		for (var i=0; i<extendedEdges.length; i++){
			var edge = extendedEdges[i];
			drawSimpleLine(edge.p1, edge.p2);
		}
	}
	
	function redrawAllCurrentEdgesCanvas2(){
		for (var i=0; i<edges.length; i++){
			var edge = edges[i];
			drawLineCanvas2(edge[0], edge[1]);
		}
		for (var i=0; i<relevantEdges.length; i++){
			var edge = relevantEdges[i];
			drawLineCanvas2(edge.p1, edge.p2);
		}
		for (var i=0; i<extendedEdges.length; i++){
			var edge = extendedEdges[i];
			drawLineCanvas2(edge.p1, edge.p2);
		}
	}
	
	
	function redrawAllTriangles(){
		for (let i=0; i< triangles.length; i++){
			drawLineCanvas2(triangles[i].p1, triangles[i].p2);
			drawLineCanvas2(triangles[i].p2, triangles[i].p3);
			drawLineCanvas2(triangles[i].p1, triangles[i].p3);
		}
	}
	
	
	function drawLineCanvas2(p1, p2){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.moveTo(p1.x, p1.y);
		ctx.lineTo(p2.x, p2.y);
		ctx.closePath();
		ctx.stroke();
	}
	
	function changePoints(){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		for (let i=0; i<points.length; i++){
			points[i].x = points[i].x - rect.left + 700;
			points[i].y = points[i].y - rect.top + 400;
		}
	}
	
	function drawPoint(point){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		ctx.beginPath();
		ctx.arc(point.x - rect.left, point.y - rect.top, 4, 0, 2*Math.PI);
		ctx.fillStyle = pointColour;
		ctx.fill();
	}
	
	function drawPointCanvas2(point){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		ctx.beginPath();
		if (point.colour == 'black'){
			ctx.arc(point.x, point.y, 4, 0, 2*Math.PI);
		} else {
			ctx.arc(point.x, point.y, 4, 0, 2*Math.PI);
		}
		
		ctx.fillStyle = point.colour;
		ctx.fill();
	}
	
	function createPointsAtInfinity(){
		let canvas2 = document.getElementById('myCanvas2');
		let ctx2 = canvas2.getContext('2d');
		let rect2 = canvas2.getBoundingClientRect();
		let p1 = new Point(1000, 0, 'black');
		let p2 = new Point(0, 1000, 'black');
		let p3 = new Point(2000, 1000, 'black');
		for (let i=0; i<points.length; i++){
			extendedPoints.push(points[i]);
		}
		extendedPoints.push(p1);
		extendedPoints.push(p2);
		extendedPoints.push(p3);
		extendedEdges.push(new Edge(p1, p2));
		extendedEdges.push(new Edge(p2, p3));
		extendedEdges.push(new Edge(p1, p3));
		
		drawPointCanvas2(p1);
		drawPointCanvas2(p2);
		drawPointCanvas2(p3);
		drawLineCanvas2(extendedEdges[0].p1, extendedEdges[0].p2);
		drawLineCanvas2(extendedEdges[1].p1, extendedEdges[1].p2);
		drawLineCanvas2(extendedEdges[2].p1, extendedEdges[2].p2);
	}
	
	function checkDelaunayTriangle(p1, p2, p3){
		let yDelta1 = p2.y - p1.y;
		let xDelta1 = p2.x - p1.x;
		let yDelta2 = p3.y - p2.y;
		let xDelta2 = p3.x - p2.x;
		
		let center = new Point(0,0,'black');
		
		let slope1 = yDelta1/xDelta1;
		let slope2 = yDelta2/xDelta2;
		
		center.x = (slope1*slope2*(p1.y-p3.y) + slope2*(p1.x+p2.x) - slope1*(p2.x+p3.x))/(2*(slope2-slope1));
		center.y = -1*(center.x - (p1.x+p2.x)/2)/slope1 + (p1.y+p2.y)/2;
		return center;
	}	
	
	function drawFirstCircles(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let x = 0;
		function moveCircle(p, pointsSet){
			advanceCenter();
			let radius = calculateDistance(p, currentCenter);
			currentRay = radius;
			if ((checkPointOnBoundary(pointsSet))){
				p = currentlyFoundPoint;
				pointsSet = redPoints;
				if (i >= 2){
					edges = [[currentlyFoundPoint, currentPoints[0]]];
					if (!relevantPoints.includes(currentlyFoundPoint)){
						relevantPoints.push(currentlyFoundPoint);
					}
					if (!relevantPoints.includes(currentPoints[0])){
						relevantPoints.push(currentPoints[0]);
					}
					let e = new Edge(currentlyFoundPoint, currentPoints[0]);
					if (!relevantEdges.includes(e)){
						relevantEdges.push(e);
					}
					var c = document.getElementById("myCanvas");
					var ctx = c.getContext("2d");
					ctx.clearRect(0, 0, c.width, c.height);
					redrawAllPoints();
					redrawAllCurrentEdges();
					i=1;
					currentlyFoundPoint = 0;
					return;
				}
				drawNextCircle();
				i++;
			}
			var c = document.getElementById("myCanvas");
			var ctx = c.getContext("2d");
			ctx.clearRect(0, 0, c.width, c.height);
			redrawAllPoints();
			redrawAllCurrentEdges();
			ctx.beginPath();
			ctx.arc(currentCenter.x-rect.left, currentCenter.y-rect.top, currentRay, 0, 2*Math.PI);
			ctx.closePath();
			ctx.stroke();
			setTimeout(moveCircle, 100, p, pointsSet);
		};
		if (p1.colour == "red"){
			currentCenter = p1;
			moveCircle(p1, bluePoints);
		} else {
			currentCenter = p2;
			moveCircle(p2, bluePoints);
		}
	}
	
	function drawNextCircle(){
		var c = document.getElementById("myCanvas");
		var ctx = c.getContext("2d");
		edges[1] = [currentlyFoundPoint, currentCenter];
		currentPoints[0] = currentlyFoundPoint; 
		currentPoints[1] = currentCenter;
		currentRay = 1;
		ctx.beginPath();
		ctx.arc(currentCenter.x-rect.left, currentCenter.y-rect.top, 8, 0, 2*Math.PI);
		ctx.closePath();
		ctx.fillStyle = "green";
		ctx.fill();
		ctx.beginPath();
		ctx.arc(currentlyFoundPoint.x-rect.left, currentlyFoundPoint.y-rect.top, 8, 0, 2*Math.PI);
		ctx.closePath();
		ctx.fillStyle = "yellow";
		ctx.fill();
		currentCenter = currentlyFoundPoint;
		ctx.beginPath();
		ctx.arc(currentCenter.x-rect.left, currentCenter.y-rect.top, currentRay, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
		drawSimpleLine(currentPoints[0], currentPoints[1]);
	}
	
	function checkPointOnBoundary(pointsSet){
		let xc = currentCenter.x;
		let yc = currentCenter.y;
		for (let i=0; i<pointsSet.length; i++){
			let distanceToPoint = calculateDistance(currentCenter, pointsSet[i]);
			if (distanceToPoint <= currentRay){
			currentlyFoundPoint = pointsSet[i];
				return true;
			}
		}
		currentlyFoundPoint = currentPoints[1];
		return false;
	}
	
	function checkPointOnBoundaryGrowingRay(){
		let xc = currentCenter.x;
		let yc = currentCenter.y;
		for (let i=0; i<extendedPoints.length; i++){
			let distanceToPoint = calculateDistance(currentCenter, extendedPoints[i]);
			if (distanceToPoint <= currentRay){
			currentlyFoundPoint = extendedPoints[i];
				return true;
			}
		}
		return false;
	}
	
	function drawRedCircle(p){
		var c = document.getElementById("myCanvas");
		var ctx = c.getContext("2d");
		ctx.beginPath();
		ctx.arc(currentPoints[0].x-rect.left, current.y-rect.top, radius, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
	}
	
	
	function drawBlueCircle(edge, p){
	}
	
	function calculateXdistance(p1, p2){
		let xDist = p2.x - p1.x;
		if (xDist<0){
			xDist = -xDist;
		}
		return xDist;
	}
	
	function calculateDistance(p1, p2){
		let x1 = p1.x;
		let y1 = p1.y;
		let x2 = p2.x;
		let y2 = p2.y;
		
		let distance = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
		return distance;
	}
	
	function calculateM(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let m = ((p2.y - rect.top)-(p1.y - rect.top))/((p2.x - rect.left)-(p1.x - rect.left));
		return m;
	}
	
	function advanceCenter(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let m = calculateM();
		if (m<0){
			m = -m;
		}
		let x1 = p1.x - rect.left;
		let y1 = p1.y - rect.top;
		let x2 = p2.x - rect.left;
		let y2 = p2.y - rect.top;
		let xc = 0;
		let yc = 0;
		if (p1.x < p2.x){
			xc = currentCenter.x + 1;
		} else {
			xc = currentCenter.x - 1;
		}
		if (p1.y < p2.y){
			yc = currentCenter.y + m;
		} else {
			yc = currentCenter.y - m;
		}
		currentCenter = new Point(xc, yc, "black");
	}
	
	function drawLine(p1, p2){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.moveTo(redPoints[p1].x - rect.left, redPoints[p1].y - rect.top);
		ctx.lineTo(bluePoints[p2].x - rect.left, bluePoints[p2].y - rect.top);				
		ctx.closePath();	
		ctx.stroke();
	}
	
	function drawSimpleLine(p1, p2){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.moveTo(p1.x - rect.left, p1.y - rect.top);
		ctx.lineTo(p2.x - rect.left, p2.y - rect.top);
		ctx.closePath();
		ctx.stroke();
	}
	
	function growCircle(center, p1, p2, p3){
		let distance = calculateDistance(center, p1);
		if (checkPointOnBoundaryGrowingRay() || currentRay >= distance){
			if (currentlyFoundPoint === p1){
				t = new Triangle(p2, p3, currentlyFoundPoint);
			drawLineCanvas2(p2, currentlyFoundPoint);
			drawLineCanvas2(p3, currentlyFoundPoint);
			return true;
			}
			return false;
		}
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		redrawAllCurrentEdgesCanvas2();
		redrawAllPointsCanvas2Next();
		ctx.beginPath();
		ctx.arc(center.x, center.y, currentRay, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
		i++;
		currentRay++;
		setTimeout(growCircle, 100, center, p1, p2, p3);
	}
	
	function drawCircleCanvas2(){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.arc(currentCenter.x, currentCenter.y, currentRay, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
	}
	
	function drawCircleCanvas2Red(){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.arc(currentCenter.x, currentCenter.y, currentRay, 0, 2*Math.PI);
		ctx.closePath();
		ctx.strokeStyle = "red";
		ctx.stroke();
	}
	
	function createPoint(evt){
		let xCoord = evt.clientX;
		let yCoord = evt.clientY;
		let p = new Point(xCoord, yCoord, pointColour);
		points.push(p);
		if (pointColour == "red"){
			redPoints.push(p);
		} else {
			bluePoints.push(p);
		}
		drawPoint(p);
	}
	
		
	function setInitialPoint(P){
		let best = null;
		for (let i = 0; i < P.length; ++i){
			if (best===null || P[i].x < best.x){
				best = P[i];
			}
		}
		initialPoint = best;
		var index = P.indexOf(initialPoint);
		P.splice(index,1);
	}
	
	function partitionP(P){
		calculateK();
		let m = calculate_m();
		let pList = [];
		let i = 0;
		for (i=0; i<P.length-m; i=i+m){
			let subList = [];
			for (let j=i; j<i+m; j++){
				subList.push(P[j]);
			}
			pList.push(subList);
		}
		let subList = [];
		for (let j=i; j<P.length; j++){
			subList.push(P[j]);
		}
		pList.push(subList);
		return pList;
	}
	

	function delaunayTriangulation(){
		
	}
	
	function redrawCanvas2(){
		let canvas = document.getElementById('myCanvas2');
		let ctx = canvas.getContext('2d');
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		createPointsAtInfinity();
		redrawAllPointsCanvas2Beginning();
		redrawAllTriangles();
	}
	
	
	
		window.onload = function () {
		let canvas = document.getElementById('myCanvas');
		canvas.addEventListener('click',createPoint);
	
		let colourButton = document.getElementById("colour");
		colourButton.addEventListener("click", function () {
                if (isColourRed) {
                    pointColour = "blue";
                    this.innerHTML = "Red";
					isColourRed = false;
                }
                else {
                    pointColour = "red";
                    this.innerHTML = "Blue";
					isColourRed = true;
                }
            });
		let saveButton = document.getElementById("saveB");
		saveButton.addEventListener("click", function() {
				let p1 = 0;
				let p2 = 0;
				while (true){
					if (redPoints.length >= 1){
						p1 = Math.floor(Math.random()*redPoints.length);
						currentPoints[0] = redPoints[p1];
						firstRandomEdge[0] = redPoints[p1];
					} else {
						// TODO error gestion
					}
					if (bluePoints.length >= 1){
						p2 = Math.floor(Math.random()*bluePoints.length);
						currentPoints[1] = bluePoints[p2];
						firstRandomEdge[1] = bluePoints[p2];
					} else {
						// TODO error gestion
					}
					let e = new Edge(redPoints[p1], bluePoints[p2]);
					if (!relevantEdges.includes(e)){ //TODO Not correct
						break;
					}
				}
				
				document.getElementById("saveB").disabled=true;
				document.getElementById("colour").disabled=true;
				canvas.removeEventListener('click',createPoint);
				edges[0] = [redPoints[p1], bluePoints[p2]];
				drawSimpleLine(redPoints[p1], bluePoints[p2]);
			});	
		let circleButton = document.getElementById("circleB");
		circleButton.addEventListener("click", function() {
				drawFirstCircles();
			});
		let nextButton = document.getElementById("nextB")
		nextButton.addEventListener("click", function() {
				//currentRay = 1;
				i = 1;
				createPointsAtInfinity();
				changePoints();
				redrawAllPointsCanvas2Beginning();
				redrawAllCurrentEdgesCanvas2();
				let j = 0;
				let found = false;
				while ((j<extendedPoints.length) && !found){
					let broken = false;
					if ((extendedPoints[j] !== relevantPoints[0])&&(extendedPoints[j] !== relevantPoints[1])){
						let center = checkDelaunayTriangle(relevantPoints[0], relevantPoints[1], extendedPoints[j]);
						currentCenter = center;
						currentRay = calculateDistance(currentCenter, relevantPoints[0]);
						drawCircleCanvas2();
						for (let k = 0; k<extendedPoints.length; k++){
							if ((extendedPoints[k] !== relevantPoints[0])&&(extendedPoints[k] !== relevantPoints[1])&&(extendedPoints[k] !== extendedPoints[j])){
								let dist = calculateDistance(extendedPoints[k], currentCenter);
								if (dist < currentRay){
									broken = true;
									break;
								}
							}
						}
						if (!broken){
							currentlyFoundPoint = extendedPoints[j];
							break;
						}
					}
					j++;
				}
				triangles.push(new Triangle(relevantPoints[0], relevantPoints[1], currentlyFoundPoint));
				redrawCanvas2();
				drawCircleCanvas2Red();
				/*
				let canvas0 = document.getElementById('myCanvas0');
				let ctx0 = canvas0.getContext('2d');
				let rect0 = canvas0.getBoundingClientRect();
				ctx0.beginPath();
				ctx0.arc(10, 320, 10, 0, 2*Math.PI);
				ctx0.fillStyle = pointColour;
				ctx0.fill();
				*/
		/*
				
				console.log(extendedEdges);
				//drawSimpleLine(extendedEdges[0].p1, extendedEdges[0].p2);
				var c = document.getElementById("myCanvas");
				var ctx = c.getContext("2d");
				ctx.beginPath();
				ctx.moveTo(extendedEdges[0].p1.x - rect.left, extendedEdges[0].p1.y - rect.top);
				ctx.lineTo(extendedEdges[0].p2.x - rect.left, extendedEdges[0].p2.y - rect.top);
				ctx.closePath();
				ctx.stroke();
				//drawSimpleLine(extendedEdges[1].p1, extendedEdges[1].p2);
				//drawSimpleLine(extendedEdges[2].p1, extendedEdges[2].p2);
		*/
			});	
	}
	

	</script>
	<style> body {padding: 0; margin: 5;} </style>
</head>

<body>

<h1> Nearest neighbour decision boundary </h1>
This website is dedicated to explaining and illustrating the paper called 
<strong>Nearest neighbour decision boundary</strong>, by <em>David Bremmer, Erik Demaine, 
Jeff Erickson, John Iacono, Stefan Langerman, Pat Morin, Godfried Toussaint</em>.
<h2> Problem definition </h2>
<p>The nearest neighbour problem is an optimisation problem. When receiving a new point, its goal is to find the nearest point to the new point
from a given set of points. All points have a colour (in this website we will work on a 2 colours basis : each point is either red or blue). The new
point will receive the same colour as its closest neighbour.<br>
In this case, we consider that our points are found in a limited plane surface, and the distance between them is the physical distance in the plane.</p>
<h3> More formal definition </h3>
We have a set <em>S</em> called training set of <em>n</em> points, separated in two subsets : the subset <em>R</em> (red points) and the subset <em>B</em> 
(blue points). The nearest neighbour problem aims to find the colour of a new point <em>q</em>, given the fact that <em>q</em>'s colour will be the colour
 of its closest neighbour from <em>S</em>. The nearest neighbour rule partitions the plane into a red and a blue set, which meet at the decision boundary.
<h2> Voronoi Condensing </h2>
<p>One interesting observation is that all points from the training set <em>S</em> are not useful for solving the problem, and therefore the size of the training
set can be reduced in order to obtain better time results. One method for reducing the training set size is based on the construction of Voronoi diagrams.
The method goes as follows : Construct the Voronoi diagram for the given points. For each cell, if it is only surrounded by cells of the same colour,
delete the point. This method is called <strong>Voronoi condensing</strong>. The Voronoi condensing can be done in <em>O(n logn)</em>.</p>
<p>However, we shall describe a method that allows us to do the Voronoi condensing in <em>O(n logk)</em>, where k is the numbber of points that remain
after condensing. </p>
<h2> Delaunay triangulations </h2>
The method we will use in our website is based on Delaunay triangulations. Let us first give some definitions: <br>
A <strong>Delaunay triangle</strong> in S is a triangle whose vertices <em>v1, v2, v3</em> are in S and such that the circle with <em>v1</em>, <em>v2</em> 
and <em>v3</em> on its boundary does not contain any point from S in it.<br>
A <strong>Delaunay triangulation</strong> of S is a partitioning of the convex hull of S into Delaunay triangles.<br>
A <strong>Delaunay edge</strong> is a line segment whose vertices <em>v1, v2</em> are in S and such that there exists a circle with <em>v1</em> and <em>v2</em>
on its boundary such that it does not contain any point from S in its interior.<br>
A <strong>bichromatic Delaunay edge</strong> is a Delaunay edge whose two vertices have different colours, i.e. one is red and the other one is blue.<br>
A <strong>bichromatic Delaunay triangle</strong> is a Delaunay triangle whose set of defining vertices contain two vertices of different colours, i.e. there 
is at least one blue vertex and at least one red vertex.<br>
If S is in general position (i.e. there exists no set of 4 points from S such that they all lie on the boundary of the same circle), then the Delaunay
triangulation is unique and contains all the Delaunay edges. Thus, finding all the bichromatic Delaunay edges can be used to compute the nearest neighbour
decision boundary.
<h3> Pivots </h3>
<p>A very useful tool we will use in order to construct Delaunay triangulations is the <em>pivot operation</em>, which works as follows : <br>
Given a ray, the pivot operations returns the biggest circle whose center is on the ray, has the origin of the ray on its boundary and has no point of S 
in its interior.</p>
<p>At the very end of this website, you can find a Canvas in which you can add red and blue points by clicking on it. This Canvas will be used to illustrate
the algorithm step by step. The first step explained in the Canvas is the pivot. Therefore, in order to have a clear representation of what a pivot is, one
should read the following sections, and then go perform a pivot operation in the canvas.</p>
<h3> Finding the first edge </h3>
To begin, we will try to find a bichromatic edge in the set of points S. We will begin by linking any Red point from S to any blue point from S, creating a ray.
<h4> First circle </h4>
Let's call the previously selected red point <em>r</em>, the previously selected blue point <em>b</em> and the previously formed ray <em>RAY</em>.
We will apply the pivot operation with ray <em>RAY</em> on <em>B</em>, with origin on <em>r</em>. By definition of the pivot operation, the formed circle is 
the maximal one without any point from <em>B</em> in its interior. Therefore, there must be a point from <em>B</em>, let's call it <em>b'</em>, on the boundary
of the formed circle (otherwise the circle could possibly be extended). Note that <em>b'</em> could possibly be <em>b</em>. Let's call the obtained circle 
<em>C</em>
<h4> Second circle </h4>
<p>The first circle is done and we can now build a second one. Let us create a new ray, called <em>RAY2</em>. This ray unites <em>b'</em> and the center of 
<em>C</em>. We pivot on the set <em>R</em> with ray <em>RAY1</em> and origin <em>b'</em>. By doing this, we obtain a second circle, that we shall call
<em>C1</em>.</p>
<p>First of all, by creation, <em>C'</em> is inside <em>C</em>. Second, we know that <em>C'</em> has <em>b'</em> and some red point <em>r'</em> on its boundary.
Third, we know that there are no points of <em>B</em> in <em>C</em>. Finally, we also know that by construction there are no points from <em>R</em> in 
<em>C1</em>. Therefore, there is no point from <em>S</em> in <em>C1</em>. We have thus created a circle with no point from <em>S</em> in its interior and
with a red point <em>r'</em> and a blue one <em>b'</em> on its boundary. We can conclude that <em>(r',b')</em> is a bichromatic edge.</p> 
<p>In order to obtain a more visual explanation, you can now perform a pivot in the Canvas at the end of the page.</p>
<h4> Bringing Complexity in </h4>
<p>After having observed the pivot illustration or simply after having read the above paragraphs, one can conclude that the complexity for growing the circles
is ridiculously high if the points happen to have relatively big distances between them. In fact, for any 1 &le; m &le; n, there exists a data structure
of size <em>O(m)</em> that can be constructed in <em>O(n log m)</em> time and that can perform pivots in <em>O((n/m) log m)</em> time per pivot. This is done
by applying Chan's data structure to partition <em>S</em> into m/n groups of size m, and applying the Dobkin-Kirkpatrick data structure on each group. The
Dobkin-Kirkpatrick data structure pre-processes a set of n points in <em>O(n log n)</em> time and performs pivot queries in <em>O(log n)</em>. To perform
a query, each data structure is queried and the smallest found circle is returned.</p>
<p> Therefore, what is the final complexity for the Pivot? The time to construct the m/n data structures is <em>m/n * O(m log m) = O(n log m)</em>, where 
O(m log m) is the complexity of forming the convex hull for a set of points. Finally, as we have said, a query is performed in <em>O(log m)</em> for each data
structure, thus a total of <em>m/n * O(log m) = O(n/m log m).</em></p>
<h3> Finding additional points </h3>
<p>We shall call <em>Q</em> the subset of <em>S</em> representing the set of vertices of <em>S</em> that contribute to the decision boundary. We shall also call
<em>P</em> the current set of found relevant vertices. Therefore, we have the relation <em>P</em> &sube; <em>Q</em> &sube; <em>S</em>.</p>
By the rule of the two circles applied above, <em>Q</em> already contains an edge (i.e., 2 vertices). In order to find additional edges, we shall use the 
<strong>Augmented Delaunay triangulation</strong> method. This method consists in finding the Delaunay triangulation of <em>P</em> &cup; <em>{v1, v2, v3}</em> 
where <em>v1, v2, v3</em> are 3 black vertices set to infinity. We call them black in order not to give them the same colour as any of the points from 
<em>S</em>. Please note that <em>v1, v2, v3</em> &#8840; <em>S</em>.</p>
For any triangle <em>t</em>, we will call <em>C(t)</em> the circle that contains the 3 vertices defining <em>t</em> on its boundary. We will use the following
lemma : <br>
Let &#8709;&ne;<em>P</em>&sube;<em>Q</em>. The following statements are equivalent : <br>
1. For every triangle t in the augmented Delaunay triangulation of <em>P</em>, if t has a blue (resp. red) vertex then <em>C(t)</em> does not have a red (resp.
blue) point of S in its interior. <br>
2. <em>P</em>=<em>Q</em>. <br>

<p>In order to find the additional points, we will iterate on each triangle <em>t</em> from the current Delaunay triangulation of <em>P</em>. If <em>t</em>
contains a blue vertex <em>b</em>, then pivot in <em>R</em> along the ray with origin at <em>b</em> and passing through <em>C(t)</em>. If the result is
<em>C(t)</em> itself, move on. Else, there must be a red point <em>r</em> on the boundary of the found circle. This point should normally be in <em>Q</em>.
Add <em>r</em> to <em>Q</em> and continue. The same should also be done for <em>t</em> with a red vertex (then the pivot is done on <em>B</em>). If both pivots
find the circle <em>C(t)</em>, then we have proved the first subpoint of the previous lemma for <em>t</em>. When this is the result for all the triangles, 
we can conclude that we have found the complete set of relevant vertices. </p>

<canvas id="myCanvas" width="640" height="480" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>
<button id="colour">Blue</button>
<button id="saveB">First line</button>
<button id="circleB">Pivot</button>
<button id="nextB">Next</button>

<canvas id="myCanvas2" width="2000" height="1000" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

</body>
</html>



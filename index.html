<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script language="javascript" type="text/javascript">

	class Point {
		constructor(x, y, colour) {
			this.x = x;
			this.y = y;
			this.colour = colour;
		}
	}
		
	var points = [];
	var redPoints = [];
	var bluePoints = [];
	var isColourRed = true;
	var pointColour = "red";
	var rect = 0;
	var edges = [];
	var currentPoints = [];
	var firstRandomEdge = [];
	var currentCenter = 0;
	var currentRay = 0;
	var currentlyFoundPoint = 0;
	var i = 1;
	
	function redrawAllPoints(){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		for (var i=0; i<points.length; i++){
			var point = points[i];
			ctx.beginPath();
			ctx.arc(point.x - rect.left, point.y - rect.top, 4, 0, 2*Math.PI);
			ctx.fillStyle = point.colour;
			ctx.fill();
		}
	}
	
	function redrawAllCurrentEdges(){
		for (var i=0; i<edges.length; i++){
			var edge = edges[i];
			drawSimpleLine(edge[0], edge[1]);
		}
	}
	
	function drawPoint(point){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext('2d');
		rect = canvas.getBoundingClientRect();
		ctx.beginPath();
		ctx.arc(point.x - rect.left, point.y - rect.top, 4, 0, 2*Math.PI);
		ctx.fillStyle = pointColour;
		ctx.fill();
	}
	
	function drawFirstCircles(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let x = 0;
		function moveCircle(p, pointsSet){
			advanceCenter();
			let radius = calculateDistance(p, currentCenter);
			currentRay = radius;
			if ((checkPointOnBoundary(pointsSet))){
				p = currentlyFoundPoint;
				pointsSet = redPoints;
				if (i >= 2){
					edges = [[currentlyFoundPoint, currentPoints[0]]];
					var c = document.getElementById("myCanvas");
					var ctx = c.getContext("2d");
					ctx.clearRect(0, 0, c.width, c.height);
					redrawAllPoints();
					redrawAllCurrentEdges();
					return;
				}
				drawNextCircle();
				i++;
			}
			var c = document.getElementById("myCanvas");
			var ctx = c.getContext("2d");
			ctx.clearRect(0, 0, c.width, c.height);
			redrawAllPoints();
			redrawAllCurrentEdges();
			ctx.beginPath();
			ctx.arc(currentCenter.x-rect.left, currentCenter.y-rect.top, currentRay, 0, 2*Math.PI);
			ctx.closePath();
			ctx.stroke();
			setTimeout(moveCircle, 100, p, pointsSet);
		};
		if (p1.colour == "red"){
			currentCenter = p1;
			moveCircle(p1, bluePoints);
		} else {
			currentCenter = p2;
			moveCircle(p2, bluePoints);
		}
	}
	
	function drawNextCircle(){
		var c = document.getElementById("myCanvas");
		var ctx = c.getContext("2d");
		edges[1] = [currentlyFoundPoint, currentCenter];
		currentPoints[0] = currentlyFoundPoint; 
		currentPoints[1] = currentCenter;
		currentRay = 1;
		currentCenter = currentlyFoundPoint;
		ctx.beginPath();
		ctx.arc(currentCenter.x-rect.left, currentCenter.y-rect.top, currentRay, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
		drawSimpleLine(currentPoints[0], currentPoints[1]);
	}
	
	function checkPointOnBoundary(pointsSet){
		let xc = currentCenter.x;
		let yc = currentCenter.y;
		for (let i=0; i<pointsSet.length; i++){
			let distanceToPoint = calculateDistance(currentCenter, pointsSet[i]);
			if (distanceToPoint <= currentRay){
			currentlyFoundPoint = pointsSet[i];
				return true;
			}
		}
		currentlyFoundPoint = currentPoints[1];
		return false;
	}
	
	function drawRedCircle(p){
		var c = document.getElementById("myCanvas");
		var ctx = c.getContext("2d");
		ctx.beginPath();
		ctx.arc(currentPoints[0].x-rect.left, current.y-rect.top, radius, 0, 2*Math.PI);
		ctx.closePath();
		ctx.stroke();
	}
	
	
	function drawBlueCircle(edge, p){
	}
	
	function calculateXdistance(p1, p2){
		let xDist = p2.x - p1.x;
		if (xDist<0){
			xDist = -xDist;
		}
		return xDist;
	}
	
	function calculateDistance(p1, p2){
		let x1 = p1.x;
		let y1 = p1.y;
		let x2 = p2.x;
		let y2 = p2.y;
		
		let distance = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
		return distance;
	}
	
	function calculateM(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let m = ((p2.y - rect.top)-(p1.y - rect.top))/((p2.x - rect.left)-(p1.x - rect.left));
		return m;
	}
	
	function advanceCenter(){
		let p1 = currentPoints[0];
		let p2 = currentPoints[1];
		let m = calculateM();
		if (m<0){
			m = -m;
		}
		let x1 = p1.x - rect.left;
		let y1 = p1.y - rect.top;
		let x2 = p2.x - rect.left;
		let y2 = p2.y - rect.top;
		let xc = 0;
		let yc = 0;
		if (p1.x < p2.x){
			xc = currentCenter.x + 1;
		} else {
			xc = currentCenter.x - 1;
		}
		if (p1.y < p2.y){
			yc = currentCenter.y + m;
		} else {
			yc = currentCenter.y - m;
		}
		currentCenter = new Point(xc, yc, "black");
	}
	
	function drawLine(p1, p2){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.moveTo(redPoints[p1].x - rect.left, redPoints[p1].y - rect.top);
		ctx.lineTo(bluePoints[p2].x - rect.left, bluePoints[p2].y - rect.top);				
		//ctx.closePath();	
		ctx.stroke();
	}
	
	function drawSimpleLine(p1, p2){
		let canvas = document.getElementById('myCanvas');
		let ctx = canvas.getContext("2d");
		ctx.beginPath();
		ctx.moveTo(p1.x - rect.left, p1.y - rect.top);
		ctx.lineTo(p2.x - rect.left, p2.y - rect.top);
		//ctx.closePath();
		ctx.stroke();
	}
	
	
	function createPoint(evt){
		let xCoord = evt.clientX;
		let yCoord = evt.clientY;
		let p = new Point(xCoord, yCoord, pointColour);
		points.push(p);
		if (pointColour == "red"){
			redPoints.push(p);
		} else {
			bluePoints.push(p);
		}
		drawPoint(p);
	}
	
	
	window.onload = function () {
		let canvas = document.getElementById('myCanvas');
		canvas.addEventListener('click',createPoint);
	
		let colourButton = document.getElementById("colour");
		colourButton.addEventListener("click", function () {
                if (isColourRed) {
                    pointColour = "blue";
                    this.innerHTML = "Red";
					isColourRed = false;
                }
                else {
                    pointColour = "red";
                    this.innerHTML = "Blue";
					isColourRed = true;
                }
            });
		let saveButton = document.getElementById("saveB");
		saveButton.addEventListener("click", function() {
				let p1 = 0;
				let p2 = 0;
				if (redPoints.length >= 1){
					p1 = Math.floor(Math.random()*redPoints.length);
					currentPoints[0] = redPoints[p1];
					firstRandomEdge[0] = redPoints[p1];
				} else {
					// TODO error gestion
				}
				if (bluePoints.length >= 1){
					p2 = Math.floor(Math.random()*bluePoints.length);
					currentPoints[1] = bluePoints[p2];
					firstRandomEdge[1] = bluePoints[p2];
				} else {
					// TODO error gestion
				}
				document.getElementById("saveB").disabled=true;
				document.getElementById("colour").disabled=true;
				canvas.removeEventListener('click',createPoint);
				edges[0] = [redPoints[p1], bluePoints[p2]];
				drawSimpleLine(redPoints[p1], bluePoints[p2]);
			});
			
		let circleButton = document.getElementById("circleB");
		circleButton.addEventListener("click", function() {
				drawFirstCircles();
			})
	}
	

	</script>
	<style> body {padding: 0; margin: 5;} </style>
</head>

<body>

<h1> Nearest neighbour decision boundary </h1>
This website is dedicated to explaining and illustrating the paper called 
<strong>Nearest neighbour decision boundary</strong>, by <em>David Bremmer, Erik Demaine, 
Jeff Erickson, John Iacono, Stefan Langerman, Pat Morin, Godfried Toussaint</em>.
<h2> Problem definition </h2>
<p>The nearest neighbour problem is an optimisation problem. When receiving a new point, its goal is to find the nearest point to the new point
from a given set of points. All points have a colour (in this website we will work on a 2 colours basis : each point is either red or blue). The new
point will receive the same colour as its closest neighbour.<br>
In this case, we consider that our points are found in a limited plane surface, and the distance between them is the physical distance in the plane.</p>
<p> This problem has many real-world applications. For example, TODO </p>
<h3> More formal definition </h3>
We have a set <em>S</em> called training set of <em>n</em> points, separated in two subsets : the subset <em>R</em> (red points) and the subset <em>B</em> 
(blue points). The nearest neighbour problem aims to find the colour of a new point <em>q</em>, given the fact that <em>q</em>'s colour will be the colour
 of its closest neighbour from <em>S</em>. The nearest neighbour rule partitions the plane into a red and a blue set, which meet at the decision boundary.
<h2> Voronoi Condensing </h2>
<p>One interesting observation is that all points from the training set <em>S</em> are not useful for solving the problem, and therefore the size of the training
set can be reduced in order to obtain better time results. One method for reducing the training set size is based on the construction of Voronoi diagrams.
The method goes as follows : Construct the Voronoi diagram for the given points. For each cell, if it is only surrounded by cells of the same colour,
delete the point. This method is called <strong>Voronoi condensing</strong>. The Voronoi condensing can be done in <em>O(n logn)</em>.</p>
<p>However, we shall describe a method that allows us to do the Voronoi condensing in <em>O(n logk)</em>, where k is the numbber of points that remain
after condensing. </p>
<h2> Delaunay triangulations </h2>
The method we will use in our website is based on Delaunay triangulations. Let us first give some definitions: <br>
A <strong>Delaunay triangle</strong> in S is a triangle whose vertices <em>v1, v2, v3</em> are in S and such that the circle with <em>v1</em>, <em>v2</em> 
and <em>v3</em> on its boundary does not contain any point from S in it.<br>
A <strong>Delaunay triangulation</strong> of S is a partitioning of the convex hull of S into Delaunay triangles.<br>
A <strong>Delaunay edge</strong> is a line segment whose vertices <em>v1, v2</em> are in S and such that there exists a circle with <em>v1</em> and <em>v2</em>
on its boundary such that it does not contain any point from S in its interior.<br>
A <strong>bichromatic Delaunay edge</strong> is a Delaunay edge whose two vertices have different colours, i.e. one is red and the other one is blue.<br>
A <strong>bichromatic Delaunay triangle</strong> is a Delaunay triangle whose set of defining vertices contain two vertices of different colours, i.e. there 
is at least one blue vertex and at least one red vertex.<br>
If S is in general position (i.e. there exists no set of 4 points from S such that they all lie on the boundary of the same circle), then the Delaunay
triangulation is unique and contains all the Delaunay edges. Thus, finding all the bichromatic Delaunay edges can be used to compute the nearest neighbour
decision boundary.
<h3> Pivots </h3>
A very useful tool we will use in order to construct Delaunay triangulations is the <em>pivot operation</em>, which works as follows : <br>
Given a ray, the pivot operations returns the biggest circle whose center is on the ray, has the origin of the ray on its boundary and has no point of S 
in its interior. 
<h3> Finding the first edge </h3>
To begin, we will try to find a bichromatic edge in the set of points S. We will begin by linking any Red point from S to any blue point from S, creating a ray.
<h4> First circle </h4>
Let's call the previously selected red point <em>r</em>, the previously selected blue point <em>b</em> and the previously formed ray <em>RAY</em>.
We will apply the pivot operation with ray <em>RAY</em> on <em>B</em>, with origin on <em>r</em>. By definition of the pivot operation, the formed circle is 
the maximal one without any point from <em>B</em> in its interior. Therefore, there must be a point from <em>B</em>, let's call it <em>b'</em>, on the boundary
of the formed circle (otherwise the circle could possibly be extended). Note that <em>b'</em> could possibly be <em>b</em>. Let's call the obtained circle 
<em>C</em>
<h4> Second circle </h4>
<p>The first circle is done and we can now build a second one. Let us create a new ray, called <em>RAY2</em>. This ray unites <em>b'</em> and the center of 
<em>C</em>. We pivot on the set <em>R</em> with ray <em>RAY1</em> and origin <em>b'</em>. By doing this, we obtain a second circle, that we shall call
<em>C1</em>.</p>
<p>First of all, by creation, <em>C'</em> is inside <em>C</em>. Second, we know that <em>C'</em> has <em>b'</em> and some red point <em>r'</em> on its boundary.
Third, we know that there are no points of <em>B</em> in <em>C</em>. Finally, we also know that by construction there are no points from <em>R</em> in 
<em>C1</em>. Therefore, there is no point from <em>S</em> in <em>C1</em>. We have thus created a circle with no point from <em>S</em> in its interior and
with a red point <em>r'</em> and a blue one <em>b'</em> on its boundary. We can conclude that <em>(r',b')</em> is a bichromatic edge.</p> 
<h3> Finding additional points </h3>
<p>We shall call <em>Q</em> the subset of <em>S</em> representing the set of vertices of <em>S</em> that contribute to the decision boundary. We shall also call
<em>P</em> the current set of found relevant vertices. Therefore, we have the relation <em>P</em> &sube; <em>Q</em> &sube; <em>S</em>.</p>
By the rule of the two circles applied above, <em>Q</em> already contains an edge (i.e., 2 vertices). In order to find additional edges, we shall use the 
<strong>Augmented Delaunay triangulation</strong> method. This method consists in finding the Delaunay triangulation of <em>P</em> &cup; <em>{v1, v2, v3}</em> 
where <em>v1, v2, v3</em> are 3 black vertices set to infinity. We call them black in order not to give them the same colour as any of the points from 
<em>S</em>. Please note that <em>v1, v2, v3</em> &#8840; <em>S</em>.</p>
For any triangle <em>t</em>, we will call <em>C(t)</em> the circle that contains the 3 vertices defining <em>t</em> on its boundary. We will use the following
lemma : <br>
Let &#8709;&ne;<em>P</em>&sube;<em>Q</em>. The following statements are equivalent : <br>
1. For every triangle t in the augmented Delaunay triangulation of <em>P</em>, if t has a blue (resp. red) vertex then <em>C(t)</em> does not have a red (resp.
blue) point of S in its interior. <br>
2. <em>P</em>=<em>Q</em>. <br>

<p>In order to find the additional points, we will iterate on each triangle <em>t</em> from the current Delaunay triangulation of <em>P</em>. If <em>t</em>
contains a blue vertex <em>b</em>, then pivot in <em>R</em> along the ray with origin at <em>b</em> and passing through <em>C(t)</em>. If the result is
<em>C(t)</em> itself, move on. Else, there must be a red point <em>r</em> on the boundary of the found circle. This point should normally be in <em>Q</em>.
Add <em>r</em> to <em>Q</em> and continue. The same should also be done for <em>t</em> with a red vertex (then the pivot is done on <em>B</em>). If both pivots
find the circle <em>C(t)</em>, then we have proved the first subpoint of the previous lemma for <em>t</em>. When this is the result for all the triangles, 
we can conclude that we have found the complete set of relevant vertices. </p>

<canvas id="myCanvas" width="640" height="480" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>
<button id="colour">Blue</button>
<button id="saveB">First line</button>
<button id="circleB">Draw Circles</button>
</body>
</html>
